#!/usr/local/bin/node


const {
    promises: fs,
} = require('fs');

const path = require('path');



const validateParsedData = (
    data,
) => {
    if (!Array.isArray(data)) {
        return false;
    }

    for (const item of data) {
        if (
            !Array.isArray(item)
            && typeof item !== 'object'
        ) {
            return false;
        }
    }

    return true;
}


const composeStage = (
    index,
    stage,
) => {
    if (!stage.imagene) {
        console.log(`Stage ${index} has no imagene.`);
        return;
    }

    let stageString = `# Stage ${index}\n`;

    const fromString = 'FROM ' + stage.imagene + '\n';
    stageString += fromString;

    if (stage.arguments) {
        stage.arguments.forEach(value => {
            stageString += 'ARG ' + value + '\n';
        });
    }

    if (stage.environment) {
        for (const [key, value] of Object.entries(stage.environment)) {
            stageString += 'ENV ' + key + ' ' + value + '\n';
        }
    }

    if (stage.directory) {
        const workdirString = 'WORKDIR ' + stage.directory + '\n';
        stageString += workdirString;
    }

    if (stage.actions) {
        stageString += stage.actions.join('\n');
        stageString += '\n';
    }

    if (stage.literals) {
        stageString += stage.literals.join('\n');
        stageString += '\n';
    }

    if (stage.command) {
        stageString += 'CMD [';
        stage.command.forEach((value, index) => {
            const endString = index < stage.command.length - 1
                ? ', '
                : '';
            stageString += `"${value}"` + endString;
        });
        stageString += ']' + '\n';
    }

    return stageString;
}


const readDeonFile = async (
    file,
    Deon,
) => {
    try {
        const deon = new Deon.default();
        const parsedData = await deon.parseFile(file);

        return parsedData;
    } catch (error) {
        console.log(`Could not read '.deon' file: '${file}'`);
    }
}


const writeDockerfile = async (
    data,
    source,
    target,
) => {
    try {
        const validData = validateParsedData(data);

        if (!validData) {
            console.log(`Invalid data in '.deon' file '${source}'`);
            return;
        }

        let dockerText = `# Dockerfile generated by 'docker-deon'.\n\n`;

        for (const [index, stage] of data.entries()) {
            if (Array.isArray(stage)) {
                dockerText += `# Stage ${index}\n`;
                dockerText += stage.join('\n');

                const endString = index < data.length - 1
                    ? '\n\n\n'
                    : '\n';
                dockerText += endString;
                continue;
            }

            dockerText += composeStage(
                index,
                stage,
            );
        }

        const targetPath = path.isAbsolute(target)
            ? target
            : path.join(process.cwd(), target);

        await fs.writeFile(
            targetPath,
            dockerText,
        );
    } catch (error) {
        console.log(`Could not write 'Dockerfile' file '${target}'`);
    }
}


const main = async () => {
    try {
        const {
            execSync,
         } = require('child_process');

        const root = execSync('npm root -g')
            .toString()
            .trim();


        const Deon = require(`${root}/@plurid/deon`);

        const source = process.argv[2] || 'dockerfile.deon';
        const target = process.argv[3] || 'Dockerfile';

        const parsedData = await readDeonFile(
            source,
            Deon,
        );

        await writeDockerfile(
            parsedData,
            source,
            target,
        );

        return;
    } catch (error) {
        console.log(
            `Something went wrong. Ensure that '@plurid/deon' is installed and functional Â· https://manual.plurid.com/deon/getting-started`,
        );
    }
}


main();
